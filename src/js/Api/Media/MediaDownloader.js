import {FileAPI} from "../Files/FileAPI"

class MediaDownloader {
    constructor(document) {
        this.isActive = false;
        this.realtime = false;
        this.chunkStart = 0;
        this.chunkSize = 0;
        this.totalLength = 0;
        this.chunkTimeout = 1000;
        this.url = null;
        this.callback = null;
        this.eof = false;
        this.setDownloadTimeoutCallback = null;
        this.document = document
    }

    setDownloadTimeoutCallback(callback) {
        this.setDownloadTimeoutCallback = callback;
        return this;
    }

    reset() {
        this.chunkStart = 0;
        this.totalLength = 0;
        this.eof = false;
        return this;
    }

    setRealTime(_realtime) {
        this.realtime = _realtime;
        return this;
    }

    setChunkSize(_size) {
        this.chunkSize = _size;
        return this;
    }

    setChunkStart(_start) {
        this.chunkStart = _start;
        this.eof = false;
        return this;
    }

    setInterval(_timeout) {
        this.chunkTimeout = _timeout;
        return this;
    }

    setUrl(_url) {
        this.url = _url;
        return this;
    }

    setCallback(_callback) {
        this.callback = _callback;
        return this;
    }

    isStopped() {
        return !this.isActive;
    }

    getFileLength() {
        return this.totalLength;
    }

    start() {
        console.log("Downloader", "Starting file download");
        this.chunkStart = 0;
        this.resume();
        return this;
    }

    resume() {
        console.log("Downloader", "Resuming file download");
        this.isActive = true;
        if (this.chunkSize === 0) {
            this.chunkSize = Infinity;
        }
        this.getFile();
        return this;
    }

    stop() {
        Log.info("Downloader", "Stopping file download");
        this.isActive = false;
        if (this.timeoutID) {
            window.clearTimeout(this.timeoutID);
            delete this.timeoutID;
        }
        return this;
    }

    getFile() {
        const dl = this

        if (dl.totalLength && this.chunkStart >= dl.totalLength) {
            dl.eof = true;
        }

        if (dl.eof === true) {
            console.log("Downloader", "File download done.");
            this.callback(null, true);
            return;
        }

        const promise = FileAPI.downloadDocumentPart(this.document, null, this.chunkSize, this.chunkStart);

        // const xhr = new XMLHttpRequest()
        // xhr.open("GET", this.url, true);
        // xhr.responseType = "arraybuffer";
        // var range = null;
        // xhr.start = this.chunkStart;
        //
        // let maxRange

        // if (this.chunkStart + this.chunkSize < Infinity) {
        //     range = 'bytes=' + this.chunkStart + '-';
        //     maxRange = this.chunkStart + this.chunkSize - 1;
        //     /* if the file length is known we limit the max range to that length */
        //     /*if (dl.totalLength !== 0) {
        //         maxRange = Math.min(maxRange, dl.totalLength);
        //     }*/
        //     range += maxRange;
        //     xhr.setRequestHeader('Range', range);
        // }

        // xhr.onerror = function (e) {
        //     dl.callback(null, false, true);
        // }

        dl.totalLength = this.document.size;

        promise.then(file => {

        })

        xhr.onreadystatechange = function (e) {

                dl.eof = (xhr.response.byteLength !== dl.chunkSize) || (xhr.response.byteLength === dl.totalLength);
                var buffer = xhr.response;
                buffer.fileStart = xhr.start;

                if (!buffer.fileStart) {
                    // IE does not support adding properties to an ArrayBuffer generated by XHR
                    buffer = buffer.slice(0);
                    buffer.fileStart = xhr.start;
                }

                dl.callback(buffer, dl.eof);

                if (dl.isActive === true && dl.eof === false) {
                    var timeoutDuration = 0;
                    if (!dl.realtime) {
                        timeoutDuration = dl.chunkTimeout;
                    } else {
                        timeoutDuration = computeWaitingTimeFromBuffer(video);
                    }
                    if (dl.setDownloadTimeoutCallback) dl.setDownloadTimeoutCallback(timeoutDuration);
                    Log.info("Downloader", "Next download scheduled in " + Math.floor(timeoutDuration) + ' ms.');
                    dl.timeoutID = window.setTimeout(dl.getFile.bind(dl), timeoutDuration);
                } else {
                    /* end of file */
                    dl.isActive = false;
                }
            // }
        };

        if (dl.isActive) {
            console.log("Downloader", "Fetching " + this.url + (range ? (" with range: " + range) : ""));
            xhr.send();
        }
    }
}

export default MediaDownloader;